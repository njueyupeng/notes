[TOC]

# 数组

本文将整理目前遇到的所有js数组知识。

## 第一层境界


1. 数组的本质是对象
```js
    typeof [1,2,3] // "object"
```

2. 数组的特殊性在于，键名是按次序的整数
```js
    Object.keys([1,2,3])// ["0","1","2"]
```
3. 数组的length属性是一个动态值，等于键名中最大整数加1。
4. 数组索引值是基于0的32位数值。（建议复习一下计算机原理）。第一个索引值是0，最大是（2的32次方-2）,差不多是42.9亿(42949672894),最大容纳42949672895个。
5. 对于length属性，针对非稀疏数组，这个属性就是数组元素的个数，针对稀疏数组，这个属性是最大索引值+1.
6. 数组的实现是经过优化的，用数字索引访问数组元素一般来说比访问常规的对象属性要快很多。

## 第二层境界

1. 创建数组时，如果省略数组直接量中的某个值，省略的元素被赋予undefined值。
```js
     var a = [1,,3];//[1,undefined,3]
```
2. 数组直接量的语法允许有可选的结尾的逗号，所以[,,]有两个元素而非三个。
```js
    var a = [,,];//[undefined,undefined]
```
3. 构造函数
```js
var a  = new Array();//[]
var b = new Array(10);
b.length;//10   这里对b的具体值是什么还有待探索
```

4. 所有的索引都是属性名，但是只有0~（2^32-2）整数属性名才是索引,也只有这个范围内的属性名，才使得数组更新length值。

```js
a[-1.23] = 10;//将创建一个名为"-1.23"的属性名
a["1000"];//等于a[1000]
a[1.00]//等于a[1]
```
5. 基于以上特性，javascript不存在数组越界的概念，查询不存在的属性时，将得到undefined。

6. 稀疏数组是包含从0开始的不连续索引的数组。可以用Array（）构造函数或简单地指定数组的索引值大于当前的数组长度来创建稀疏数组。
```js
a = new Array(5);//数组没有元素，但是a.length是5
a = []; //创建一个空数组，length=0
a[1000] = 0;//赋值添加一个元素，但是设置length为1001
```

## 第三层境界

1. 足够稀疏的数组，通常在实现上比稠密的数组更慢，内存利用率更高（为什么？），在这样的数组中查找元素的时间与常规对象属性的查找时间一样长。

> 经检验，第二点中用in操作符判断的方法，无法判断，返回结果都是false。（出自javascript权威指南原文147页）。

2. 当在数组直接量中省略值时不会创建稀疏数组。省略的元素在数组中是存在的，其值为undefined。可以用in操作符检验两者的区别：
```js
    var a1 = [1,1,1] //[undefined,undefined,undefined]
    var a2 = nwe Array(3)/、该数组根本没有元素。
    0 in a1;//true ：a1在索引0处有一个元素
    0 in a2;//false a2在索引0处没有元素
```

3. 当数组是稀疏数组时，length属性值大于元素的个数，对于非稀疏数组，length属性值代表数组中元素的个数。也就是说，在数组中，肯定找不到一个元素的索引值大于或等于它的长度。为了位置此规则不变化，数组有两个特殊的行为：如果为一个数组元素赋值，它的索引i大于或等于现有的长度时，length属性的值设置为i+1;设置length属性为一个小于当前长度的非负整数n时，当前数组中那些索引值大于或等于n的元素将从中删除。
```js
a = [1,2,3,4,5];
a.length = 3;//[1,2,3]
a.length=0;//[]
a.length = 5;//new Array(5)
```

## 第四层境界：使用数组的方法

### 1. join()

Array.join()方法将数组中所有元素都转化为字符串并连接在一起，返回最后生成的字符串。可以指定一个可选的字符串作为分隔符。如果不指定，默认使用逗号。
```js
var a = [1,2,3];
a.join();//"1,2,3"
a.join(" ");//"1 2 3",也就是说，执行join方法，a本身不被改变，只是返回新数组
a.join("");//"123"
var b = new Array(5);
b.join("-");//'----':四个连字号组成的字符串
```

Array.join()方法是String.split()方法的逆向操作，后者是将字符串分割成若干块来创建一个数组。

### 2.reverse()
Array.reverse()方法将数组中的元素颠倒顺序，它对原先的数组进行了改变。
```
var =  [1,2,3];
a.reverse();//[3,2,1]
a;//[3,2,1]

```

### 3.sort()
1. Array.sort()方法将数组中的元素排序并返回排序后的数组。当不带参数调用sort()时，数组元素以字母表顺序排序（如有必要，将临时转化为字符串进行比较）
```js
var a = new Array('b','c','a');
a.sort();["a","b","c"]
a;["a","b","c"]
var s = a.join(", ");//'a, b, c'
b = ["b","C","A"];
b.sort();//["A","C","b"]
```
> 如果数组包含undefined元素，他们会被排到数组的尾部。

2. sort()方法可以接收比较一个函数，该函数决定了他的两个参数在排好序的数组中的先后顺序。假设第一个参数应该在前，则比较函数应该返回一个小于0的数值。反之，假设第一个参数应该在后，函数应该返回一个大于0的数值。假设两个值相等，函数应该返回0.
```js
var a = [33,4,1111,222];
a.sort();//[1111,222,33,4]——字母表顺序
a.sort(function(a,b){//4,33,222,1111
    return a-b;
})

b = ['ant','Bug','cat','Dog']
b.sort();
b.sort(function(s,t){
    var a = s.toLowerCase();
    var b = t.toLowerCase();
    if(a<b) return -1;
    if(a>b) return 1;
    return 0;
})
```

### 4.concat()

Array.concat()方法创建并返回一个新数组，它的元素包括调用concat()的原始数组的元素和concat()的每个参数。如果这些参数的任何一个自身是数组，则连接的是数组的元素，而非数组本身。但要注意，concat()不会递归扁平化数组的数组。concat()也不会修改调用的数组。
```js
var a = [1,2,3];
a.concat(4,5);//[1,2,3,4,5]
a.concat([4,5]);//[1,2,3,4,5]
a.concat([4,5],[6,7]);//[1,2,3,4,5,6]
a.concat(4,[5,[6,7]);//[1,2,3,4,5,[6,7]]
```

### 5.slice()
Array.slice()方法返回指定数组的一个片段或子数组。它的两个参数分别指定了片段的开始和结束的位置（返回的数组，包含第一个，不包含第二个。如果参数出现负数，则表示相对于数组的最后一个元素的位置。
> slice()不会修改调用的数组。
```js
var a = [1,2,3,4,5];
a.slice(1,3);//[1,2,3]
a.slice(3);//[4,5]
a.slice(1,-1);//[2,3,4]
a.slice(-3,-2);//[3]
a.slice(2,0);//[]
```


### 6.splice()
Array.splice()方法是在数组中插入或删除元素的通用方法。不同于slice()和concat(),splice会修改调用的数组。注意：splice()和slice()拥有非常相似的名字，但它们的功能却又本质的区别。

splice()能够从数组中删除元素、插入元素到数组中或者同时完成这两种操作。


### 7.push()和pop()

### 8.unshift()和shift()

### 9.toString()和toLocaleString()

## 第五层境界：使用ES5的方法

### 1.forEach()
forEach()方法从头到尾遍历数组，为每个元素调用指定的函数。传递的函数作为forEach()的第一个参数。然后forEach()使用三个参数调用该函数：数组元素、元素索引和数组本身。如果只关心元素的值，可以只编写一个参数。
```js
var data = [1,2,3,4,5];
var sum = 0;
data.forEach(function(value){sum+=value});//求和
data.forEach(function(v,i,a){a[i]=v+1});//每个元素加一
```

### 2.map()

map()方法将调用的数组的每个元素传递给指定的函数，并返回一个数组，它包含该函数的返回值。
```js
a = [1,2,3];
b = a.map(function(x){
    return x*x;
});//b是[1,4,9]

传递给map()的函数的调用方式和传递给forEach()的函数的调用方式一样。但传递给map()的函数应该有返回值。注意，map()返回的是新数组。如果是稀疏数组，返回的也是相同形式的稀疏数组：它具有相同的长度，相同的缺失元素。

### 3.filter()
filter()方法返回的数组元素是调用的数组的一个子集。传递的函数是用来逻辑判定的：该函数返回true或false。调用判定函数就像调用forEach()和map()一样。如果返回值为true或能转化为true的值，那么传递给判定函数的元素就是这个子集的成员，它将被添加到一个作为返回值的数组中：
```js
a = [1,2,3,4,5];
b = a.filter(function(x){return x<3});//[1,2]
c = a.filter(function(x,i){return i%2==0})//[1,3,5]
```
注意：filter()会跳过稀疏数组中缺少的元素，它的返回数组总是稠密的。为了压缩稀疏数组的空缺，代码如下：
```js
var dense = sparse.filter(function(){return true});
```
甚至，压缩空缺并删除undefined和null元素，可以这样使用filter():
```js
a = a.filter(function(x){ return x !== undefined && x !=null;})
```
